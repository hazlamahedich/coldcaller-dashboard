/**
 * Migration Runner - Execute database migrations in order
 */

const path = require('path');
const fs = require('fs').promises;

// Load environment variables first
require('dotenv').config({ path: path.resolve(__dirname, '../../../.env') });

const { sequelize } = require('../config/database');

// Migration tracking table
const createMigrationsTable = async () => {
  const [results] = await sequelize.query(`
    CREATE TABLE IF NOT EXISTS migrations (
      id INTEGER PRIMARY KEY ${sequelize.getDialect() === 'sqlite' ? 'AUTOINCREMENT' : 'GENERATED BY DEFAULT AS IDENTITY'},
      name VARCHAR(255) NOT NULL UNIQUE,
      executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `);
  return results;
};

// Get executed migrations
const getExecutedMigrations = async () => {
  try {
    const [results] = await sequelize.query('SELECT name FROM migrations ORDER BY id');
    return results.map(row => row.name);
  } catch (error) {
    return [];
  }
};

// Record migration execution
const recordMigration = async (migrationName) => {
  await sequelize.query('INSERT INTO migrations (name) VALUES (?)', {
    replacements: [migrationName]
  });
};

// Get available migration files
const getMigrationFiles = async () => {
  const migrationsDir = __dirname;
  const files = await fs.readdir(migrationsDir);
  
  return files
    .filter(file => file.match(/^\d{3}_.*\.js$/) && file !== 'runMigrations.js')
    .sort();
};

// Run individual migration
const runMigration = async (migrationFile) => {
  console.log(`ðŸ”„ Running migration: ${migrationFile}`);
  
  const migrationPath = path.join(__dirname, migrationFile);
  const migration = require(migrationPath);
  
  if (!migration.up || typeof migration.up !== 'function') {
    throw new Error(`Migration ${migrationFile} does not export an 'up' function`);
  }
  
  try {
    await migration.up(sequelize.getQueryInterface(), sequelize.constructor);
    await recordMigration(migrationFile);
    console.log(`âœ… Completed migration: ${migrationFile}`);
  } catch (error) {
    console.error(`âŒ Migration ${migrationFile} failed:`, error.message);
    throw error;
  }
};

// Main migration runner
const runMigrations = async () => {
  try {
    console.log('ðŸš€ Starting database migrations...');
    
    // Ensure database connection
    await sequelize.authenticate();
    console.log('âœ… Database connection established');
    
    // Create migrations tracking table
    await createMigrationsTable();
    console.log('âœ… Migrations tracking table ready');
    
    // Get migration status
    const executedMigrations = await getExecutedMigrations();
    const availableMigrations = await getMigrationFiles();
    const pendingMigrations = availableMigrations.filter(
      file => !executedMigrations.includes(file)
    );
    
    console.log(`ðŸ“Š Migration Status:`);
    console.log(`   - Total migrations: ${availableMigrations.length}`);
    console.log(`   - Executed: ${executedMigrations.length}`);
    console.log(`   - Pending: ${pendingMigrations.length}`);
    
    if (pendingMigrations.length === 0) {
      console.log('âœ… No pending migrations. Database is up to date.');
      return;
    }
    
    // Run pending migrations
    console.log('ðŸ”„ Executing pending migrations...');
    for (const migrationFile of pendingMigrations) {
      await runMigration(migrationFile);
    }
    
    console.log('ðŸŽ‰ All migrations completed successfully!');
    
    // Show final status
    const finalExecutedMigrations = await getExecutedMigrations();
    console.log(`ðŸ“Š Final Status: ${finalExecutedMigrations.length} migrations executed`);
    
  } catch (error) {
    console.error('ðŸ’¥ Migration process failed:', error);
    process.exit(1);
  } finally {
    await sequelize.close();
  }
};

// Rollback functionality
const rollbackMigration = async (migrationFile) => {
  console.log(`ðŸ”„ Rolling back migration: ${migrationFile}`);
  
  const migrationPath = path.join(__dirname, migrationFile);
  const migration = require(migrationPath);
  
  if (!migration.down || typeof migration.down !== 'function') {
    throw new Error(`Migration ${migrationFile} does not export a 'down' function`);
  }
  
  try {
    await migration.down(sequelize.getQueryInterface(), sequelize.constructor);
    await sequelize.query('DELETE FROM migrations WHERE name = ?', {
      replacements: [migrationFile]
    });
    console.log(`âœ… Rolled back migration: ${migrationFile}`);
  } catch (error) {
    console.error(`âŒ Rollback of ${migrationFile} failed:`, error.message);
    throw error;
  }
};

// Command line interface
const main = async () => {
  const command = process.argv[2];
  const target = process.argv[3];
  
  switch (command) {
    case 'up':
      await runMigrations();
      break;
      
    case 'down':
      if (!target) {
        console.error('âŒ Please specify migration file to rollback');
        process.exit(1);
      }
      await sequelize.authenticate();
      await rollbackMigration(target);
      await sequelize.close();
      break;
      
    case 'status':
      await sequelize.authenticate();
      const executed = await getExecutedMigrations();
      const available = await getMigrationFiles();
      const pending = available.filter(file => !executed.includes(file));
      
      console.log('ðŸ“Š Migration Status:');
      console.log(`   Executed (${executed.length}):`);
      executed.forEach(file => console.log(`   âœ… ${file}`));
      console.log(`   Pending (${pending.length}):`);
      pending.forEach(file => console.log(`   â³ ${file}`));
      
      await sequelize.close();
      break;
      
    default:
      await runMigrations();
  }
};

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('ðŸ’¥ Command failed:', error);
    process.exit(1);
  });
}

module.exports = {
  runMigrations,
  rollbackMigration,
  getMigrationFiles,
  getExecutedMigrations
};