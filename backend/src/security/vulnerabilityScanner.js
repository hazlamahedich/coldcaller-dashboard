/**
 * Vulnerability Scanner and Security Testing Module
 * Automated security scanning and dependency monitoring
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');
const axios = require('axios');

// Configuration
const SCAN_CONFIG = {
  // Dependency scanning
  dependencies: {
    enabled: true,
    sources: ['npm', 'snyk', 'github'],
    severityThreshold: 'moderate', // low, moderate, high, critical
    autoFix: process.env.NODE_ENV !== 'production'
  },
  
  // Code scanning
  code: {
    enabled: true,
    patterns: {
      secrets: true,
      sqlInjection: true,
      xss: true,
      hardcodedPasswords: true,
      insecureConnections: true
    }
  },
  
  // Container scanning (if using Docker)
  container: {
    enabled: process.env.DOCKER_SCAN_ENABLED === 'true',
    registry: process.env.CONTAINER_REGISTRY
  },
  
  // API security testing
  api: {
    enabled: true,
    baseUrl: process.env.API_BASE_URL || 'http://localhost:3001',
    endpoints: [
      '/api/auth/login',
      '/api/leads',
      '/api/calls',
      '/api/sip',
      '/api/analytics'
    ]
  }
};

/**
 * Dependency Vulnerability Scanner
 */
class DependencyScanner {
  constructor() {
    this.vulnerabilities = [];
    this.lastScan = null;
  }
  
  async scanNpmAudit() {
    try {
      console.log('🔍 Running npm audit...');
      const result = execSync('npm audit --json', { 
        cwd: path.join(__dirname, '../../'),
        encoding: 'utf8' 
      });
      
      const auditData = JSON.parse(result);
      return this.parseNpmAudit(auditData);
    } catch (error) {
      // npm audit returns non-zero exit code when vulnerabilities found
      if (error.stdout) {
        try {
          const auditData = JSON.parse(error.stdout);
          return this.parseNpmAudit(auditData);
        } catch (parseError) {
          console.error('Failed to parse npm audit output:', parseError);
          return [];
        }
      }
      console.error('npm audit failed:', error.message);
      return [];
    }
  }
  
  parseNpmAudit(auditData) {
    const vulnerabilities = [];
    
    if (auditData.vulnerabilities) {
      for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
        if (vulnData.severity) {
          vulnerabilities.push({
            package: packageName,
            severity: vulnData.severity,
            title: vulnData.title,
            overview: vulnData.overview,
            recommendation: vulnData.recommendation,
            references: vulnData.references,
            vulnerableVersions: vulnData.range,
            patchedVersions: vulnData.fixAvailable,
            source: 'npm-audit'
          });
        }
      }
    }
    
    return vulnerabilities;
  }
  
  async scanGitHubAdvisories() {
    try {
      console.log('🔍 Checking GitHub Security Advisories...');
      const packageJson = await fs.readFile(
        path.join(__dirname, '../../package.json'), 
        'utf8'
      );
      const dependencies = JSON.parse(packageJson).dependencies || {};
      
      const vulnerabilities = [];
      
      // Check each dependency against GitHub Advisory Database
      for (const [packageName, version] of Object.entries(dependencies)) {
        try {
          const advisories = await this.getGitHubAdvisories(packageName);
          for (const advisory of advisories) {
            if (this.isVersionVulnerable(version, advisory.vulnerableVersionRange)) {
              vulnerabilities.push({
                package: packageName,
                severity: advisory.severity.toLowerCase(),
                title: advisory.summary,
                overview: advisory.description,
                cve: advisory.cveId,
                publishedAt: advisory.publishedAt,
                source: 'github-advisories'
              });
            }
          }
        } catch (error) {
          // Continue with other packages if one fails
          console.warn(`Failed to check advisories for ${packageName}:`, error.message);
        }
      }
      
      return vulnerabilities;
    } catch (error) {
      console.error('GitHub advisory scan failed:', error.message);
      return [];
    }
  }
  
  async getGitHubAdvisories(packageName) {
    const query = `
      query($packageName: String!) {
        securityVulnerabilities(first: 50, ecosystem: NPM, package: $packageName) {
          nodes {
            advisory {
              summary
              description
              severity
              publishedAt
              identifiers {
                type
                value
              }
            }
            vulnerableVersionRange
          }
        }
      }
    `;
    
    const response = await axios.post('https://api.github.com/graphql', {
      query,
      variables: { packageName }
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    
    return response.data.data.securityVulnerabilities.nodes.map(node => ({
      summary: node.advisory.summary,
      description: node.advisory.description,
      severity: node.advisory.severity,
      publishedAt: node.advisory.publishedAt,
      cveId: node.advisory.identifiers.find(id => id.type === 'CVE')?.value,
      vulnerableVersionRange: node.vulnerableVersionRange
    }));
  }
  
  isVersionVulnerable(installedVersion, vulnerableRange) {
    // Simplified version checking - in production, use semver library
    return true; // Placeholder
  }
  
  async performFullScan() {
    const startTime = Date.now();
    console.log('🚀 Starting dependency vulnerability scan...');
    
    const results = {
      timestamp: new Date().toISOString(),
      scanDuration: 0,
      vulnerabilities: [],
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        moderate: 0,
        low: 0
      }
    };
    
    try {
      // Run npm audit
      const npmVulns = await this.scanNpmAudit();
      results.vulnerabilities.push(...npmVulns);
      
      // Run GitHub advisories check (if token available)
      if (process.env.GITHUB_TOKEN) {
        const githubVulns = await this.scanGitHubAdvisories();
        results.vulnerabilities.push(...githubVulns);
      }
      
      // Calculate summary
      results.vulnerabilities.forEach(vuln => {
        results.summary.total++;
        results.summary[vuln.severity]++;
      });
      
      results.scanDuration = Date.now() - startTime;
      this.lastScan = results;
      
      // Save results
      await this.saveResults(results);
      
      // Check if action is required
      await this.checkThresholds(results);
      
      console.log(`✅ Vulnerability scan completed in ${results.scanDuration}ms`);
      console.log(`📊 Found ${results.summary.total} vulnerabilities: ${results.summary.critical} critical, ${results.summary.high} high`);
      
      return results;
    } catch (error) {
      console.error('❌ Vulnerability scan failed:', error);
      throw error;
    }
  }
  
  async saveResults(results) {
    const reportsDir = path.join(__dirname, '../reports');
    await fs.mkdir(reportsDir, { recursive: true });
    
    const reportFile = path.join(reportsDir, `vulnerability-scan-${Date.now()}.json`);
    await fs.writeFile(reportFile, JSON.stringify(results, null, 2));
    
    console.log(`📄 Scan results saved: ${reportFile}`);
  }
  
  async checkThresholds(results) {
    const criticalCount = results.summary.critical || 0;
    const highCount = results.summary.high || 0;
    
    if (criticalCount > 0) {
      console.error(`🚨 CRITICAL ALERT: ${criticalCount} critical vulnerabilities found!`);
      await this.sendAlert('CRITICAL', results);
    } else if (highCount > 5) {
      console.warn(`⚠️ HIGH ALERT: ${highCount} high-severity vulnerabilities found!`);
      await this.sendAlert('HIGH', results);
    }
  }
  
  async sendAlert(level, results) {
    // TODO: Implement alerting mechanism
    console.log(`📧 Security alert would be sent - Level: ${level}`);
  }
}

/**
 * Code Security Scanner
 */
class CodeScanner {
  constructor() {
    this.patterns = {
      secrets: [
        /password\s*[=:]\s*['"][^'"]+['"]/gi,
        /api[_-]?key\s*[=:]\s*['"][^'"]+['"]/gi,
        /secret\s*[=:]\s*['"][^'"]+['"]/gi,
        /token\s*[=:]\s*['"][^'"]+['"]/gi,
        /jwt[_-]?secret\s*[=:]/gi,
        /database[_-]?url\s*[=:]/gi
      ],
      sqlInjection: [
        /query\s*\+\s*['"`]/gi,
        /\$\{.*\}\s*(SELECT|INSERT|UPDATE|DELETE)/gi,
        /\.query\([^)]*\+/gi,
        /execute\([^)]*\+/gi
      ],
      xss: [
        /innerHTML\s*=\s*[^;]*\+/gi,
        /document\.write\([^)]*\+/gi,
        /\.html\([^)]*\+/gi,
        /eval\s*\(/gi
      ],
      insecureConnections: [
        /http:\/\/(?!localhost|127\.0\.0\.1)/gi,
        /ws:\/\/(?!localhost|127\.0\.0\.1)/gi
      ]
    };
  }
  
  async scanDirectory(directory) {
    const results = [];
    
    try {
      const files = await this.getJavaScriptFiles(directory);
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf8');
        const fileResults = await this.scanFile(file, content);
        results.push(...fileResults);
      }
      
      return results;
    } catch (error) {
      console.error('Code scan failed:', error);
      return [];
    }
  }
  
  async getJavaScriptFiles(directory) {
    const files = [];
    
    const scan = async (dir) => {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory() && 
            !entry.name.startsWith('.') && 
            !['node_modules', 'coverage', 'dist', 'build'].includes(entry.name)) {
          await scan(fullPath);
        } else if (entry.isFile() && 
                   (entry.name.endsWith('.js') || entry.name.endsWith('.ts'))) {
          files.push(fullPath);
        }
      }
    };
    
    await scan(directory);
    return files;
  }
  
  async scanFile(filePath, content) {
    const results = [];
    const lines = content.split('\n');
    
    // Check each pattern category
    for (const [category, patterns] of Object.entries(this.patterns)) {
      for (const pattern of patterns) {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          const lineNumber = content.substring(0, match.index).split('\n').length;
          
          results.push({
            file: filePath,
            line: lineNumber,
            category,
            pattern: pattern.source,
            match: match[0],
            severity: this.getSeverity(category),
            description: this.getDescription(category)
          });
        }
      }
    }
    
    return results;
  }
  
  getSeverity(category) {
    const severityMap = {
      secrets: 'critical',
      sqlInjection: 'high',
      xss: 'high',
      insecureConnections: 'medium'
    };
    
    return severityMap[category] || 'low';
  }
  
  getDescription(category) {
    const descriptions = {
      secrets: 'Potential hardcoded secret or credential',
      sqlInjection: 'Potential SQL injection vulnerability',
      xss: 'Potential XSS vulnerability',
      insecureConnections: 'Insecure HTTP connection detected'
    };
    
    return descriptions[category] || 'Security pattern detected';
  }
}

/**
 * API Security Scanner
 */
class APIScanner {
  constructor() {
    this.baseUrl = SCAN_CONFIG.api.baseUrl;
    this.testResults = [];
  }
  
  async scanEndpoints() {
    console.log('🔍 Starting API security scan...');
    const results = [];
    
    for (const endpoint of SCAN_CONFIG.api.endpoints) {
      const endpointResults = await this.scanEndpoint(endpoint);
      results.push(...endpointResults);
    }
    
    return results;
  }
  
  async scanEndpoint(endpoint) {
    const results = [];
    const fullUrl = `${this.baseUrl}${endpoint}`;
    
    // Test common security issues
    results.push(...await this.testSQLInjection(fullUrl));
    results.push(...await this.testXSS(fullUrl));
    results.push(...await this.testRateLimiting(fullUrl));
    results.push(...await this.testAuthentication(fullUrl));
    
    return results;
  }
  
  async testSQLInjection(url) {
    const payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "1' UNION SELECT * FROM users--",
      "admin'--"
    ];
    
    const results = [];
    
    for (const payload of payloads) {
      try {
        const response = await axios.get(url, {
          params: { q: payload },
          timeout: 5000,
          validateStatus: () => true
        });
        
        // Check for SQL error messages
        if (response.data && typeof response.data === 'string') {
          if (response.data.includes('SQL') || 
              response.data.includes('mysql') ||
              response.data.includes('ORA-')) {
            results.push({
              endpoint: url,
              vulnerability: 'SQL Injection',
              severity: 'critical',
              payload,
              evidence: 'SQL error message in response'
            });
          }
        }
      } catch (error) {
        // Ignore network errors for this test
      }
    }
    
    return results;
  }
  
  async testXSS(url) {
    const payloads = [
      "<script>alert('XSS')</script>",
      "javascript:alert('XSS')",
      "<img src=x onerror=alert('XSS')>",
      "'\"><script>alert('XSS')</script>"
    ];
    
    const results = [];
    
    for (const payload of payloads) {
      try {
        const response = await axios.get(url, {
          params: { q: payload },
          timeout: 5000,
          validateStatus: () => true
        });
        
        if (response.data && response.data.includes(payload)) {
          results.push({
            endpoint: url,
            vulnerability: 'Reflected XSS',
            severity: 'high',
            payload,
            evidence: 'Payload reflected in response'
          });
        }
      } catch (error) {
        // Ignore network errors for this test
      }
    }
    
    return results;
  }
  
  async testRateLimiting(url) {
    const results = [];
    const requests = [];
    
    // Send 20 rapid requests
    for (let i = 0; i < 20; i++) {
      requests.push(axios.get(url, {
        timeout: 5000,
        validateStatus: () => true
      }));
    }
    
    try {
      const responses = await Promise.all(requests);
      const rateLimited = responses.some(r => r.status === 429);
      
      if (!rateLimited) {
        results.push({
          endpoint: url,
          vulnerability: 'Missing Rate Limiting',
          severity: 'medium',
          evidence: 'No rate limiting detected after 20 rapid requests'
        });
      }
    } catch (error) {
      // Network errors expected with rate limiting
    }
    
    return results;
  }
  
  async testAuthentication(url) {
    const results = [];
    
    try {
      const response = await axios.get(url, {
        timeout: 5000,
        validateStatus: () => true
      });
      
      // Check if endpoint requires authentication
      if (response.status === 200 && !url.includes('/auth')) {
        results.push({
          endpoint: url,
          vulnerability: 'Missing Authentication',
          severity: 'high',
          evidence: 'Endpoint accessible without authentication'
        });
      }
    } catch (error) {
      // Ignore network errors
    }
    
    return results;
  }
}

/**
 * Main Security Scanner
 */
class SecurityScanner {
  constructor() {
    this.dependencyScanner = new DependencyScanner();
    this.codeScanner = new CodeScanner();
    this.apiScanner = new APIScanner();
  }
  
  async performComprehensiveScan() {
    console.log('🚀 Starting comprehensive security scan...');
    const startTime = Date.now();
    
    const results = {
      timestamp: new Date().toISOString(),
      scanDuration: 0,
      dependencies: {},
      code: {},
      api: {},
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      }
    };
    
    try {
      // Dependency scan
      if (SCAN_CONFIG.dependencies.enabled) {
        results.dependencies = await this.dependencyScanner.performFullScan();
      }
      
      // Code scan
      if (SCAN_CONFIG.code.enabled) {
        const codeResults = await this.codeScanner.scanDirectory(
          path.join(__dirname, '../../')
        );
        results.code = { vulnerabilities: codeResults };
      }
      
      // API scan
      if (SCAN_CONFIG.api.enabled) {
        const apiResults = await this.apiScanner.scanEndpoints();
        results.api = { vulnerabilities: apiResults };
      }
      
      // Calculate overall summary
      this.calculateSummary(results);
      
      results.scanDuration = Date.now() - startTime;
      
      console.log(`✅ Comprehensive security scan completed in ${results.scanDuration}ms`);
      console.log(`📊 Total security issues: ${results.summary.total}`);
      
      return results;
    } catch (error) {
      console.error('❌ Security scan failed:', error);
      throw error;
    }
  }
  
  calculateSummary(results) {
    const allVulns = [
      ...(results.dependencies.vulnerabilities || []),
      ...(results.code.vulnerabilities || []),
      ...(results.api.vulnerabilities || [])
    ];
    
    results.summary.total = allVulns.length;
    
    allVulns.forEach(vuln => {
      const severity = vuln.severity || 'low';
      results.summary[severity] = (results.summary[severity] || 0) + 1;
    });
  }
  
  async generateReport(results) {
    const reportDir = path.join(__dirname, '../reports');
    await fs.mkdir(reportDir, { recursive: true });
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportFile = path.join(reportDir, `security-scan-${timestamp}.json`);
    
    await fs.writeFile(reportFile, JSON.stringify(results, null, 2));
    
    console.log(`📄 Security scan report saved: ${reportFile}`);
    return reportFile;
  }
}

// Export scanner instances
module.exports = {
  SecurityScanner,
  DependencyScanner,
  CodeScanner,
  APIScanner,
  SCAN_CONFIG
};